(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{100:function(e,t,r){"use strict";r.r(t),r.d(t,"frontMatter",(function(){return s})),r.d(t,"metadata",(function(){return c})),r.d(t,"rightToc",(function(){return i})),r.d(t,"default",(function(){return u}));var n=r(3),a=r(7),o=(r(0),r(146)),s={id:"extend",title:"Extend Transform",sidebar_label:"Extend"},c={unversionedId:"transforms/extend",id:"transforms/extend",isDocsHomePage:!1,title:"Extend Transform",description:"extend transform allows you to extend the schema of the source directly on the source level. But this might cause inconsistency if the schema heavily relies on that schema's existing structure. This transform can be used for the data sources that return fixed results. For example, OpenAPI and JSON Schema handler are good examples for this kind of sources while Postgraphile and GraphQL handlers aren't because they rely on their existing structure. The resolvers added by this transform accesses directly to root, args and context of that schema, so you cannot use selectionSet (actually you shouldn't, because this is not a root level transform).",source:"@site/docs/transforms/extend.md",slug:"/transforms/extend",permalink:"/docs/transforms/extend",editUrl:"https://github.com/urigo/graphql-mesh/edit/master/website/docs/transforms/extend.md",version:"current",sidebar_label:"Extend"},i=[],l={rightToc:i};function u(e){var t=e.components,r=Object(a.a)(e,["components"]);return Object(o.b)("wrapper",Object(n.a)({},l,r,{components:t,mdxType:"MDXLayout"}),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"extend")," transform allows you to extend the schema of the source directly on the source level. But this might cause inconsistency if the schema heavily relies on that schema's existing structure. This transform can be used for the data sources that return fixed results. For example, OpenAPI and JSON Schema handler are good examples for this kind of sources while Postgraphile and GraphQL handlers aren't because they rely on their existing structure. The resolvers added by this transform accesses directly to ",Object(o.b)("inlineCode",{parentName:"p"},"root"),", ",Object(o.b)("inlineCode",{parentName:"p"},"args")," and ",Object(o.b)("inlineCode",{parentName:"p"},"context")," of that schema, so you cannot use ",Object(o.b)("inlineCode",{parentName:"p"},"selectionSet")," (actually you shouldn't, because this is not a root level transform)."),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-yml"}),"transforms:\n  - extend: \n        typeDefs: ./someTypeDefs.graphql\n        resolvers: ./someResolvers.js\n")),Object(o.b)("p",null,"You can extend the existing types in ",Object(o.b)("inlineCode",{parentName:"p"},"someTypeDefs.graphql"),";"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-graphql"}),"    extend type User {\n        fullName: String\n    }\n")),Object(o.b)("p",null,"And define resolvers for those types;"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),"module.exports = {\n    User: {\n        fullName: user => `${user.firstName} ${user.lastName}` // e.g. `user` is the raw result returned by your data source\n    }\n}\n")),Object(o.b)("p",null,Object(o.b)("ul",{parentName:"p"},Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"typeDefs")," (type: ",Object(o.b)("inlineCode",{parentName:"li"},"Any"),")"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"resolvers")," (type: ",Object(o.b)("inlineCode",{parentName:"li"},"Any"),")"))))}u.isMDXComponent=!0},146:function(e,t,r){"use strict";r.d(t,"a",(function(){return p})),r.d(t,"b",(function(){return b}));var n=r(0),a=r.n(n);function o(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function s(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function c(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?s(Object(r),!0).forEach((function(t){o(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):s(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function i(e,t){if(null==e)return{};var r,n,a=function(e,t){if(null==e)return{};var r,n,a={},o=Object.keys(e);for(n=0;n<o.length;n++)r=o[n],t.indexOf(r)>=0||(a[r]=e[r]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)r=o[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(a[r]=e[r])}return a}var l=a.a.createContext({}),u=function(e){var t=a.a.useContext(l),r=t;return e&&(r="function"==typeof e?e(t):c(c({},t),e)),r},p=function(e){var t=u(e.components);return a.a.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.a.createElement(a.a.Fragment,{},t)}},m=a.a.forwardRef((function(e,t){var r=e.components,n=e.mdxType,o=e.originalType,s=e.parentName,l=i(e,["components","mdxType","originalType","parentName"]),p=u(r),m=n,b=p["".concat(s,".").concat(m)]||p[m]||d[m]||o;return r?a.a.createElement(b,c(c({ref:t},l),{},{components:r})):a.a.createElement(b,c({ref:t},l))}));function b(e,t){var r=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var o=r.length,s=new Array(o);s[0]=m;var c={};for(var i in t)hasOwnProperty.call(t,i)&&(c[i]=t[i]);c.originalType=e,c.mdxType="string"==typeof e?e:n,s[1]=c;for(var l=2;l<o;l++)s[l]=r[l];return a.a.createElement.apply(null,s)}return a.a.createElement.apply(null,r)}m.displayName="MDXCreateElement"}}]);