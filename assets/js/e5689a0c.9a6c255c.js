(window.webpackJsonp=window.webpackJsonp||[]).push([[201],{274:function(e,t,a){"use strict";a.r(t),a.d(t,"frontMatter",(function(){return s})),a.d(t,"metadata",(function(){return i})),a.d(t,"toc",(function(){return l})),a.d(t,"default",(function(){return p}));var r=a(3),n=a(7),o=(a(0),a(299)),s={id:"mesh-transforms",title:"Mesh Transforms",sidebar_label:"4. Mesh Transforms"},i={unversionedId:"getting-started/mesh-transforms",id:"getting-started/mesh-transforms",isDocsHomePage:!1,title:"Mesh Transforms",description:"Introduction to Transforms",source:"@site/docs/getting-started/mesh-transforms.md",slug:"/getting-started/mesh-transforms",permalink:"/docs/getting-started/mesh-transforms",editUrl:"https://github.com/urigo/graphql-mesh/edit/master/website/docs/getting-started/mesh-transforms.md",version:"current",sidebar_label:"4. Mesh Transforms",sidebar:"sidebar",previous:{title:"Basic Usage",permalink:"/docs/getting-started/basic-example"},next:{title:"Extending Schema with Multiple APIs",permalink:"/docs/getting-started/multiple-apis"}},l=[{value:"Introduction to Transforms",id:"introduction-to-transforms",children:[]},{value:"Handler-level transforms",id:"handler-level-transforms",children:[]},{value:"Root-level transforms",id:"root-level-transforms",children:[]},{value:"Two different modes",id:"two-different-modes",children:[{value:"Wrap",id:"wrap",children:[]},{value:"Bare",id:"bare",children:[]},{value:"Transforms supporting &quot;bare&quot; mode",id:"transforms-supporting-bare-mode",children:[]}]}],c={toc:l};function p(e){var t=e.components,a=Object(n.a)(e,["components"]);return Object(o.b)("wrapper",Object(r.a)({},c,a,{components:t,mdxType:"MDXLayout"}),Object(o.b)("h2",{id:"introduction-to-transforms"},"Introduction to Transforms"),Object(o.b)("p",null,"GraphQL Mesh allow you to do schema transformations easily, you can use one of the built-in transforms, or write your own."),Object(o.b)("p",null,"Each transformer can manipulate the schema the way it needs, and return the modified schema."),Object(o.b)("p",null,"Transforms are specified as a list of objects, and they are executed in order, and you can apply them over a specific input source, or over the unified schema (after merging all sources)."),Object(o.b)("h2",{id:"handler-level-transforms"},"Handler-level transforms"),Object(o.b)("p",null,"To specify ",Object(o.b)("inlineCode",{parentName:"p"},"transforms")," over a specific source, add it to your ",Object(o.b)("inlineCode",{parentName:"p"},"sources")," section under the source you wish to modify."),Object(o.b)("p",null,"The following example prefixes an input source to make it simpler later to merge and avoid conflicts:"),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-yml"}),"sources:\n  - name: Wiki\n    handler:\n      openapi:\n        source: https://api.apis.guru/v2/specs/wikimedia.org/1.0.0/swagger.yaml\n    transforms:\n      - prefix:\n          value: Wiki_\n")),Object(o.b)("h2",{id:"root-level-transforms"},"Root-level transforms"),Object(o.b)("p",null,"To specify ",Object(o.b)("inlineCode",{parentName:"p"},"transforms")," over unified schema, you should put it in the root of your config file. This could be used in case you need access fields or types from all your data source, for example for linking two data sources together."),Object(o.b)("p",null,"The following example prefixes an input source to make it simpler later to merge and avoid conflicts:"),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-yml"}),"sources:\n  - name: Users\n    handler: #...\n  - name: Posts\n    handler: #...\ntransforms:\n  - cache:\n      - field: Query.user\n        cacheKey: user-{args.id}\n        invalidates:\n          effectingOperations:\n            - operation: Mutation.updateUser\n              matchKey: {args.userIdToUpdate}\n")),Object(o.b)("p",null,"The example above uses ",Object(o.b)("inlineCode",{parentName:"p"},"cache")," transform on root and when someone uses ",Object(o.b)("inlineCode",{parentName:"p"},"updateUser")," with a specific user id, it will update the data record, and then invalidate the cache automatically."),Object(o.b)("p",null,"You can learn more about caching ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"/docs/transforms/cache"}),"in the dedicated docs.")),Object(o.b)("h2",{id:"two-different-modes"},"Two different modes"),Object(o.b)("p",null,'By default, transforms works by wrapping the original schema, but recently we have also introduced a new "bare" mode to transform the original schema.\nAlthough apparently both ',Object(o.b)("inlineCode",{parentName:"p"},"bare")," and ",Object(o.b)("inlineCode",{parentName:"p"},"wrap")," modes do achieve the same result, their behaviours are very different.",Object(o.b)("br",{parentName:"p"}),"\n","Let's take a look at how they operate."),Object(o.b)("h3",{id:"wrap"},"Wrap"),Object(o.b)("p",null,"Wrap applies transformations by adding a wrapping layer to the original GraphQL schema. The handler generates a GraphQL\nschema and passes it to the transform. When in ",Object(o.b)("inlineCode",{parentName:"p"},"wrap")," mode, the transform, receives this schema and rather than updating this, it will apply a layer on top of it; with the scope of serving your transforms as an addition to the original schema generated by the handler.\nThis approach is safe as we have used it extensively in ",Object(o.b)("inlineCode",{parentName:"p"},"graphql-tools"),"; however, be mindful of the implications below."),Object(o.b)("h4",{id:"implications"},"Implications"),Object(o.b)("p",null,"Wrap is the default mode because is safe and works across all data sources, however you might want to be aware of the following implications."),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},'Runtime implications\nSchema wrapping is performed during initialisation only and so won\'t affect runtime GraphQL operations. However, some transforms do alter the original schema shape, and when this is done in "wrap" mode, the only way to achieve it, is by intercepting both the incoming request and original response in order to do the mapping required to transform these into the desired shape.\nNot all transforms require interception of both request and response and some require very simple mapping, so the runtime overhead could hopefully be negligible; however there will always be some.'),Object(o.b)("li",{parentName:"ul"},'Multiple wrapping layers\nWhen using "wrap" mode, the required transformation can be achieved by adding at least one wrapping layer per each transform rule defined. We cannot have a wrapping layer per transform, but we need one per rule since each rule is unique in the way it transforms different parts of the schema. Some rules might even require multiple wrapping layers, f.i. when transforming a field the transform need to be applied to RootFields, ObjectFields and InputObjectFields.\nAs explained on the previous point the wrapping is commited during initialisation only, however, each wrapping layer will always have some runtime implications, even if hopefully negligible.'),Object(o.b)("li",{parentName:"ul"},'Working with fixed-schema sources\nAs mentioned "wrap" is the only mode that works for sources that "speaks" GraphQL natively. However, when you work with fixed schema sources, such as JSON-schema, OpenApi, SOAP, etc.; schema wrapping might have some undesired effects; f.i. you won\'t have access to the original fixed-contract response from your data source.\nThis might be not ideal, for example, when implementing custom resolvers, where you mght want to access several the properties returned by your REST service in order to compute custom data; but instead you will only be able to access properties requested with the GraphQL query.\nIf you don\'t want/can\'t opt into "bare" mode, this can be easily solved by explicitly declaring a ',Object(o.b)("inlineCode",{parentName:"li"},"SelectionSet"),", within your custom resolver, to list all properties required in order to compute your custom data.")),Object(o.b)("blockquote",null,Object(o.b)("p",{parentName:"blockquote"},"NOTE: ",Object(o.b)("inlineCode",{parentName:"p"},"wrap"),' is the only approach that works with data sources that already "speaks" GraphQL, or when you want to transform at all-sources (root) level, unless you\'re using ',Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"https://graphql-mesh.com/docs/api/modules/merger-bare/"}),"merger-bare"),". If you want to remove the possible runtime implications, consider either moving your ",Object(o.b)("inlineCode",{parentName:"p"},"renames")," at the data source level, or opting into ",Object(o.b)("inlineCode",{parentName:"p"},"merger-bare"),"; in order to take advantage of ",Object(o.b)("inlineCode",{parentName:"p"},"bare")," mode.")),Object(o.b)("p",null,"Example:"),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-yaml"}),"sources:\n  - name: Countries\n    handler:\n      graphql:\n        endpoint: https://api.../graphql\n    transforms:\n      - rename:\n          mode: wrap # bare won't work here, since this data source already \"speaks\" GraphQL\n          renames:\n            - from:\n                type: Country\n                field: admin1Admins\n              to:\n                type: Country\n                field: admin1\n  - name: Users\n    handler:\n      openapi:\n        source: https://api.../swagger.yaml\n    transforms:\n      - rename:\n          mode: wrap # you can use either wrap or bare here\n          renames:\n            - from:\n                type: User\n                field: lastName\n              to:\n                type: User\n                field: surname\ntransforms:\n  - rename:\n      mode: wrap # bare won't work here at all-sources (root) level, because you're not using merger-bare\n      renames:\n        - from:\n            type: Country\n            field: ISO-3166_Code\n          to:\n            type: Country\n            field: code\n")),Object(o.b)("blockquote",null,Object(o.b)("p",{parentName:"blockquote"},"ProTip: When you want to use ",Object(o.b)("inlineCode",{parentName:"p"},"wrap"),', you can omit the "mode" property since this is already applied by default.  ')),Object(o.b)("h3",{id:"bare"},"Bare"),Object(o.b)("p",null,"Bare is a recent addition and works by applying transformations to the original schema. The handler generates a GraphQL schema and passes it to the transform. When in ",Object(o.b)("inlineCode",{parentName:"p"},"bare")," mode, the transform, receives the schema generated by your handler, applies the transform rules defined and finally returns an updated version of the original schema.\nThis means that the transformed schema replaces the original schema from the handler and so Mesh deals with one schema only, as opposed to an original schema plus a wrapping layer.\nBare mode does remove all the ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"#implications"}),'implications of "wrap" mode'),", however, be mindful of the restrictions below."),Object(o.b)("h4",{id:"restrictions"},"Restrictions"),Object(o.b)("p",null,"Bare does provide performance improvements over ",Object(o.b)("inlineCode",{parentName:"p"},"wrap"),"; however it has a main restriction: it needs to access the bare schema. Here are some reasons why this might not work:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},'Your data source already "speaks" GraphQL\nIn this case ',Object(o.b)("inlineCode",{parentName:"p"},"bare"),' won\'t work as it cannot replace a native GraphQL schema. This is not the same as transforming a "translated" GraphQL schema (e.g. from JSON-schema, OpenApi, SOAP, etc.).\nThe suggestion in this case is to apply ',Object(o.b)("inlineCode",{parentName:"p"},"wrap")," transforms to your GraphQL data source and ",Object(o.b)("inlineCode",{parentName:"p"},"bare"),' transforms to sources "translated" into GraphQL.')),Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"You are applying transforms at all-sources (root) level\nThis means that ",Object(o.b)("inlineCode",{parentName:"p"},"bare"),' would receive a stitched GraphQL schema, rather than a bare and "translated" schema. If you do want to use ',Object(o.b)("inlineCode",{parentName:"p"},"bare")," at the root level your only choice is to opt into ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"https://graphql-mesh.com/docs/api/modules/merger-bare/"}),"merger-bare"),', which lets transforms access the bare schemas; because it merges sources without wrapping them. This works when you don\'t have (or you take care of) conflicts between your sources, and you are not applying root-level transforms to data sources that already "speaks" GraphQL.')),Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"You are mixing transforms that supports ",Object(o.b)("inlineCode",{parentName:"p"},"bare")," with transforms that don't\nAgain, ",Object(o.b)("inlineCode",{parentName:"p"},"bare")," always need to access the bare schema. If you define other transforms that don't support ",Object(o.b)("inlineCode",{parentName:"p"},"bare")," mode, you will most likely have troubles, since those transforms will apply a wrapping layer which won't let ",Object(o.b)("inlineCode",{parentName:"p"},"bare")," transforms access the bare schema.\nIn order to take advantage of ",Object(o.b)("inlineCode",{parentName:"p"},"bare")," performance improvement, the suggestion here is to apply ",Object(o.b)("inlineCode",{parentName:"p"},"wrap")," transforms at the all-sources (root) level and ",Object(o.b)("inlineCode",{parentName:"p"},"bare")," transforms within the data sources level; so that at least you are able to reduce the number of wrapping layers that would otherwise be created if not using ",Object(o.b)("inlineCode",{parentName:"p"},"bare")," at all."))),Object(o.b)("p",null,"Example:"),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-yaml"}),"sources:\n  - name: Countries\n    handler:\n      soap:\n        wsdl: http://webservices.../wso?WSDL\n  - name: Users\n    handler:\n      openapi:\n        source: https://api.../swagger.yaml\n    transforms:\n      rename:\n          mode: bare # bare is a great choice here, at the data source level\n          renames:\n            - from:\n                type: User\n                field: lastName\n              to:\n                type: User\n                field: surname\nmerger: bare # this lets transforms access the bare schemas\ntransforms:\n  rename:\n      mode: bare # bare will work here, at all-sources (root) level, because you're using merger-bare\n      renames:\n        - from:\n            type: Country\n            field: ISO-3166_Code\n          to:\n            type: Country\n            field: code\n")),Object(o.b)("h3",{id:"transforms-supporting-bare-mode"},'Transforms supporting "bare" mode'),Object(o.b)("p",null,'Being a recent addition, "bare" mode is not available to all transforms yet.\nThe table below gives you the list of transforms that support "bare" mode. Transforms not listed here do not support "bare", and so only implement default "wrap" mode.\nIf you have use cases where you believe "bare" mode should be added to a transform not listed here, feel free to ',Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"https://github.com/Urigo/graphql-mesh/issues/new/choose"}),"open a feature request"),"."),Object(o.b)("table",null,Object(o.b)("thead",{parentName:"table"},Object(o.b)("tr",{parentName:"thead"},Object(o.b)("th",Object(r.a)({parentName:"tr"},{align:null}),"Transform"),Object(o.b)("th",Object(r.a)({parentName:"tr"},{align:"center"}),"Bare"),Object(o.b)("th",Object(r.a)({parentName:"tr"},{align:"center"}),"Wrap"))),Object(o.b)("tbody",{parentName:"table"},Object(o.b)("tr",{parentName:"tbody"},Object(o.b)("td",Object(r.a)({parentName:"tr"},{align:null}),"Extend"),Object(o.b)("td",Object(r.a)({parentName:"tr"},{align:"center"}),"\u2705"),Object(o.b)("td",Object(r.a)({parentName:"tr"},{align:"center"}),"\u274c")),Object(o.b)("tr",{parentName:"tbody"},Object(o.b)("td",Object(r.a)({parentName:"tr"},{align:null}),"Rename"),Object(o.b)("td",Object(r.a)({parentName:"tr"},{align:"center"}),"\u2705"),Object(o.b)("td",Object(r.a)({parentName:"tr"},{align:"center"}),"\u2705")),Object(o.b)("tr",{parentName:"tbody"},Object(o.b)("td",Object(r.a)({parentName:"tr"},{align:null}),"Filter Schema"),Object(o.b)("td",Object(r.a)({parentName:"tr"},{align:"center"}),"\u2705"),Object(o.b)("td",Object(r.a)({parentName:"tr"},{align:"center"}),"\u2705")))))}p.isMDXComponent=!0},299:function(e,t,a){"use strict";a.d(t,"a",(function(){return m})),a.d(t,"b",(function(){return h}));var r=a(0),n=a.n(r);function o(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function s(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,r)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?s(Object(a),!0).forEach((function(t){o(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):s(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,r,n=function(e,t){if(null==e)return{};var a,r,n={},o=Object.keys(e);for(r=0;r<o.length;r++)a=o[r],t.indexOf(a)>=0||(n[a]=e[a]);return n}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)a=o[r],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(n[a]=e[a])}return n}var c=n.a.createContext({}),p=function(e){var t=n.a.useContext(c),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},m=function(e){var t=p(e.components);return n.a.createElement(c.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return n.a.createElement(n.a.Fragment,{},t)}},b=n.a.forwardRef((function(e,t){var a=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),m=p(a),b=r,h=m["".concat(s,".").concat(b)]||m[b]||d[b]||o;return a?n.a.createElement(h,i(i({ref:t},c),{},{components:a})):n.a.createElement(h,i({ref:t},c))}));function h(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=a.length,s=new Array(o);s[0]=b;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i.mdxType="string"==typeof e?e:r,s[1]=i;for(var c=2;c<o;c++)s[c]=a[c];return n.a.createElement.apply(null,s)}return n.a.createElement.apply(null,a)}b.displayName="MDXCreateElement"}}]);