(window.webpackJsonp=window.webpackJsonp||[]).push([[109],{180:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return s})),n.d(t,"metadata",(function(){return i})),n.d(t,"toc",(function(){return c})),n.d(t,"default",(function(){return u}));var r=n(3),a=n(7),o=(n(0),n(299)),s={id:"extend",title:"Extend Transform (experimental)",sidebar_label:"Extend"},i={unversionedId:"transforms/extend",id:"transforms/extend",isDocsHomePage:!1,title:"Extend Transform (experimental)",description:"extend transform allows you to extend the schema of the source directly on the source level. But this might cause inconsistency if the schema heavily relies on that schema's existing structure. This transform can be used for the data sources that return fixed results. For example, OpenAPI and JSON Schema handler are good examples for this kind of sources while Postgraphile and GraphQL handlers aren't because they rely on their existing structure. The resolvers added by this transform accesses directly to root, args and context of that schema, so you cannot use selectionSet (actually you shouldn't, because this is not a root level transform).",source:"@site/docs/transforms/extend.md",slug:"/transforms/extend",permalink:"/docs/transforms/extend",editUrl:"https://github.com/urigo/graphql-mesh/edit/master/website/docs/transforms/extend.md",version:"current",sidebar_label:"Extend",sidebar:"sidebar",previous:{title:"Naming Convention Transform",permalink:"/docs/transforms/naming-convention"},next:{title:"TypeScript Support",permalink:"/docs/recipes/typescript"}},c=[{value:"How to use?",id:"how-to-use",children:[]},{value:"Config API Reference",id:"config-api-reference",children:[]}],l={toc:c};function u(e){var t=e.components,n=Object(a.a)(e,["components"]);return Object(o.b)("wrapper",Object(r.a)({},l,n,{components:t,mdxType:"MDXLayout"}),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"extend")," transform allows you to extend the schema of the source directly on the source level. But this might cause inconsistency if the schema heavily relies on that schema's existing structure. This transform can be used for the data sources that return fixed results. For example, OpenAPI and JSON Schema handler are good examples for this kind of sources while Postgraphile and GraphQL handlers aren't because they rely on their existing structure. The resolvers added by this transform accesses directly to ",Object(o.b)("inlineCode",{parentName:"p"},"root"),", ",Object(o.b)("inlineCode",{parentName:"p"},"args")," and ",Object(o.b)("inlineCode",{parentName:"p"},"context")," of that schema, so you cannot use ",Object(o.b)("inlineCode",{parentName:"p"},"selectionSet")," (actually you shouldn't, because this is not a root level transform)."),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Note:")," This transform is not able to access other sources, it can be only used in the source level."),Object(o.b)("blockquote",null,Object(o.b)("p",{parentName:"blockquote"},"Please DO NOT use this transform unless you know what you're doing! We strongly recommend you to extend the schema using ",Object(o.b)("inlineCode",{parentName:"p"},"additionalTypeDefs")," and ",Object(o.b)("inlineCode",{parentName:"p"},"additionalResolvers")," as described in ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"/docs/getting-started/multiple-apis"}),"Extend Schema")," part in this documentation.")),Object(o.b)("h2",{id:"how-to-use"},"How to use?"),Object(o.b)("p",null,"Add the following configuration under the source configuration;"),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-yml"}),"transforms:\n  - extend:\n      typeDefs: ./someTypeDefs.graphql\n      resolvers: ./someResolvers.js\n")),Object(o.b)("p",null,"You can extend the existing types in ",Object(o.b)("inlineCode",{parentName:"p"},"someTypeDefs.graphql"),";"),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-graphql"}),"extend type User {\n  fullName: String\n}\n")),Object(o.b)("p",null,"And define resolvers for those types;"),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-js"}),"module.exports = {\n  User: {\n    fullName: user => `${user.firstName} ${user.lastName}`, // e.g. `user` is the raw result returned by your data source\n  },\n}\n")),Object(o.b)("h2",{id:"config-api-reference"},"Config API Reference"),Object(o.b)("p",null,Object(o.b)("ul",{parentName:"p"},Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"typeDefs")," (type: ",Object(o.b)("inlineCode",{parentName:"li"},"Any"),")"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"resolvers")," (type: ",Object(o.b)("inlineCode",{parentName:"li"},"Any"),")"))))}u.isMDXComponent=!0},299:function(e,t,n){"use strict";n.d(t,"a",(function(){return p})),n.d(t,"b",(function(){return m}));var r=n(0),a=n.n(r);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=a.a.createContext({}),u=function(e){var t=a.a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=u(e.components);return a.a.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.a.createElement(a.a.Fragment,{},t)}},b=a.a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,l=c(e,["components","mdxType","originalType","parentName"]),p=u(n),b=r,m=p["".concat(s,".").concat(b)]||p[b]||d[b]||o;return n?a.a.createElement(m,i(i({ref:t},l),{},{components:n})):a.a.createElement(m,i({ref:t},l))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,s=new Array(o);s[0]=b;var i={};for(var c in t)hasOwnProperty.call(t,c)&&(i[c]=t[c]);i.originalType=e,i.mdxType="string"==typeof e?e:r,s[1]=i;for(var l=2;l<o;l++)s[l]=n[l];return a.a.createElement.apply(null,s)}return a.a.createElement.apply(null,n)}b.displayName="MDXCreateElement"}}]);