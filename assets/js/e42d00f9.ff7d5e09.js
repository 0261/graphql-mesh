"use strict";(self.webpackChunk_graphql_mesh_website=self.webpackChunk_graphql_mesh_website||[]).push([[8506],{5318:function(e,t,r){r.d(t,{Zo:function(){return c},kt:function(){return f}});var n=r(7378);function o(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function a(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function s(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?a(Object(r),!0).forEach((function(t){o(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):a(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function i(e,t){if(null==e)return{};var r,n,o=function(e,t){if(null==e)return{};var r,n,o={},a=Object.keys(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||(o[r]=e[r]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(o[r]=e[r])}return o}var p=n.createContext({}),l=function(e){var t=n.useContext(p),r=t;return e&&(r="function"==typeof e?e(t):s(s({},t),e)),r},c=function(e){var t=l(e.components);return n.createElement(p.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var r=e.components,o=e.mdxType,a=e.originalType,p=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),d=l(r),f=o,y=d["".concat(p,".").concat(f)]||d[f]||u[f]||a;return r?n.createElement(y,s(s({ref:t},c),{},{components:r})):n.createElement(y,s({ref:t},c))}));function f(e,t){var r=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=r.length,s=new Array(a);s[0]=d;var i={};for(var p in t)hasOwnProperty.call(t,p)&&(i[p]=t[p]);i.originalType=e,i.mdxType="string"==typeof e?e:o,s[1]=i;for(var l=2;l<a;l++)s[l]=r[l];return n.createElement.apply(null,s)}return n.createElement.apply(null,r)}d.displayName="MDXCreateElement"},7036:function(e,t,r){r.r(t),r.d(t,{frontMatter:function(){return i},metadata:function(){return p},toc:function(){return l},default:function(){return u}});var n=r(5773),o=r(808),a=(r(7378),r(5318)),s=["components"],i={id:"typescript",title:"TypeScript Support",sidebar_label:"TypeScript Support"},p={unversionedId:"recipes/typescript",id:"recipes/typescript",isDocsHomePage:!1,title:"TypeScript Support",description:"GraphQL Mesh supports TypeScript, and you can easily use it to generate typings for the fetched data, and for you custom resolvers that specific under additionalResolvers",source:"@site/docs/recipes/typescript.md",sourceDirName:"recipes",slug:"/recipes/typescript",permalink:"/docs/recipes/typescript",editUrl:"https://github.com/urigo/graphql-mesh/edit/master/website/docs/recipes/typescript.md",version:"current",sidebar_label:"TypeScript Support",frontMatter:{id:"typescript",title:"TypeScript Support",sidebar_label:"TypeScript Support"},sidebar:"sidebar",previous:{title:"Build Artifacts",permalink:"/docs/recipes/build-mesh-artifacts"},next:{title:"Mesh as SDK",permalink:"/docs/recipes/as-sdk"}},l=[{value:"Type safety for custom resolvers",id:"type-safety-for-custom-resolvers",children:[]},{value:"Type safety for fetched data",id:"type-safety-for-fetched-data",children:[]}],c={toc:l};function u(e){var t=e.components,r=(0,o.Z)(e,s);return(0,a.kt)("wrapper",(0,n.Z)({},c,r,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"GraphQL Mesh supports TypeScript, and you can easily use it to generate typings for the fetched data, and for you custom resolvers that specific under ",(0,a.kt)("inlineCode",{parentName:"p"},"additionalResolvers")),(0,a.kt)("h2",{id:"type-safety-for-custom-resolvers"},"Type safety for custom resolvers"),(0,a.kt)("p",null,"GraphQL Mesh allows for API handler packages to provide TypeScript typings in order to have types support in your code."),(0,a.kt)("p",null,"First you need to install ",(0,a.kt)("inlineCode",{parentName:"p"},"ts-node")," to allow NodeJS handle ",(0,a.kt)("inlineCode",{parentName:"p"},".ts")," files before adding ",(0,a.kt)("inlineCode",{parentName:"p"},"require")," section to your configuration file like below;"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-sh"},"yarn add ts-node\n")),(0,a.kt)("p",null,"Then in your ",(0,a.kt)("inlineCode",{parentName:"p"},".meshrc.yml")," file;"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-yaml"},"require:\n  - ts-node/register/transpile-only\n\nadditionalResolvers:\n  - ./src/mesh-resolvers.ts\n")),(0,a.kt)("p",null,"Then, use the CLI command to generate the typings file based on your unified GraphQL schema:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"mesh build\n")),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"/docs/recipes/build-mesh-artifacts"},"See more about artifacts")),(0,a.kt)("p",null,"Now, you can import ",(0,a.kt)("inlineCode",{parentName:"p"},"Resolvers")," interface from the generated file, and use it as the type for your custom resolvers. It will make sure that your parent value, arguments, context type and return value are fully compatible with the implementation. It will also provide fully typed SDK from the context:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"import { Resolvers } from './.mesh';\n\nexport const resolvers: Resolvers = {\n  // Your custom resolvers here\n};\n")),(0,a.kt)("h2",{id:"type-safety-for-fetched-data"},"Type safety for fetched data"),(0,a.kt)("p",null,"See ",(0,a.kt)("a",{parentName:"p",href:"/docs/recipes/as-sdk"},"Mesh as SDK")," section."))}u.isMDXComponent=!0}}]);