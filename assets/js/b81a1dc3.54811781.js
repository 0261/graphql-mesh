"use strict";(self.webpackChunk_graphql_mesh_website=self.webpackChunk_graphql_mesh_website||[]).push([[7525],{5318:function(e,t,n){n.d(t,{Zo:function(){return u},kt:function(){return d}});var o=n(7378);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,o,a=function(e,t){if(null==e)return{};var n,o,a={},r=Object.keys(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=o.createContext({}),p=function(e){var t=o.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},u=function(e){var t=p(e.components);return o.createElement(s.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},h=o.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,s=e.parentName,u=i(e,["components","mdxType","originalType","parentName"]),h=p(n),d=a,m=h["".concat(s,".").concat(d)]||h[d]||c[d]||r;return n?o.createElement(m,l(l({ref:t},u),{},{components:n})):o.createElement(m,l({ref:t},u))}));function d(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,l=new Array(r);l[0]=h;var i={};for(var s in t)hasOwnProperty.call(t,s)&&(i[s]=t[s]);i.originalType=e,i.mdxType="string"==typeof e?e:a,l[1]=i;for(var p=2;p<r;p++)l[p]=n[p];return o.createElement.apply(null,l)}return o.createElement.apply(null,n)}h.displayName="MDXCreateElement"},5364:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return i},metadata:function(){return s},toc:function(){return p},default:function(){return c}});var o=n(5773),a=n(808),r=(n(7378),n(5318)),l=["components"],i={id:"replace-field",title:"Replace Field",sidebar_label:"Replace Field"},s={unversionedId:"transforms/replace-field",id:"transforms/replace-field",isDocsHomePage:!1,title:"Replace Field",description:"The replace-field transform allows you to replace configuration properties of a GraphQL field (source) with the ones of another field (target).",source:"@site/docs/transforms/replace-field.md",sourceDirName:"transforms",slug:"/transforms/replace-field",permalink:"/docs/transforms/replace-field",editUrl:"https://github.com/urigo/graphql-mesh/edit/master/website/docs/transforms/replace-field.md",version:"current",sidebar_label:"Replace Field",frontMatter:{id:"replace-field",title:"Replace Field",sidebar_label:"Replace Field"}},p=[{value:"How to use?",id:"how-to-use",children:[]},{value:"How the transform works",id:"how-the-transform-works",children:[]},{value:"Transform scopes",id:"transform-scopes",children:[{value:"scope: config",id:"scope-config",children:[]},{value:"scope: hoistValue",id:"scope-hoistvalue",children:[]}]},{value:"Additional type definitions",id:"additional-type-definitions",children:[]},{value:"Custom composers",id:"custom-composers",children:[]}],u={toc:p};function c(e){var t=e.components,n=(0,a.Z)(e,l);return(0,r.kt)("wrapper",(0,o.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"replace-field")," transform allows you to replace configuration properties of a GraphQL field (source) with the ones of another field (target)."),(0,r.kt)("p",null,"This is extremely useful when you want to hoist field values from one subfield to its parent, but it can be customised to completely replace and/or compose resolve functions with a great degree of customisation."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"yarn add @graphql-mesh/transform-replace-field\n")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Note: currently this transform supports ",(0,r.kt)("inlineCode",{parentName:"p"},"bare"),' mode only. For information about "bare" and "wrap" modes, please read the ',(0,r.kt)("a",{parentName:"p",href:"/docs/transforms/transforms-introduction#two-different-modes"},"dedicated section"),".")),(0,r.kt)("h2",{id:"how-to-use"},"How to use?"),(0,r.kt)("p",null,"Imagine you have generated your schema from a data source you don't control, and the generated schema looks like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-graphql"},"type Query {\n  books: BooksApiResponse\n}\n\ntype BooksApiResponse {\n  books: [Book]\n}\n\ntype Book {\n  title: String!\n  author: Author!\n  code: String\n}\n\ntype Author {\n  name: String!\n  age: Int!\n}\n")),(0,r.kt)("p",null,"As you can see you would have to request a GraphQL Document like the following, to retrieve the list of books:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-graphql"},"{\n  books {\n    books {\n      title\n      author\n    }\n  }\n}\n")),(0,r.kt)("p",null,"This is not ideal because you have to request ",(0,r.kt)("inlineCode",{parentName:"p"},"books")," as a child ",(0,r.kt)("inlineCode",{parentName:"p"},"books"),", so in this case hoisting the value from child to parent would lead to a cleaner schema and request Document."),(0,r.kt)("p",null,"To achieve this you can add the following configuration to your Mesh config file:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yml"},"transforms:\n  - replace-field:\n      replacements:\n        - from:\n            type: Query\n            field: books\n          to:\n            type: BooksApiResponse\n            field: books\n          scope: hoistValue\n")),(0,r.kt)("p",null,"This will transform your schema from what you had above, to this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-graphql"},"type Query {\n  books: [Book]\n}\n\ntype Book {\n  title: String!\n  author: Author!\n  code: String\n}\n\ntype Author {\n  name: String!\n  age: Int!\n}\n")),(0,r.kt)("p",null,"Allowing you to request a GraphQL document like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-graphql"},"{\n  books {\n    title\n    author\n  }\n}\n")),(0,r.kt)("h2",{id:"how-the-transform-works"},"How the transform works"),(0,r.kt)("p",null,"Let's understand more about how this transform works.\nWith ",(0,r.kt)("inlineCode",{parentName:"p"},"from")," you define your source, which field in the schema you want to replace."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"- from:\n    type: Query\n    field: books\n")),(0,r.kt)("p",null,"In this case, we want to replace the field ",(0,r.kt)("inlineCode",{parentName:"p"},"books")," in type ",(0,r.kt)("inlineCode",{parentName:"p"},"Query"),", which by default has the type ",(0,r.kt)("inlineCode",{parentName:"p"},"BooksApiResponse"),"."),(0,r.kt)("p",null,"With ",(0,r.kt)("inlineCode",{parentName:"p"},"to")," you define your target, and so which field should replace your identified source field."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"to:\n  type: BooksApiResponse\n  field: books\n")),(0,r.kt)("p",null,"To summarise the configuration above we want field ",(0,r.kt)("inlineCode",{parentName:"p"},"books")," in type ",(0,r.kt)("inlineCode",{parentName:"p"},"Query")," to be replaced from being of type ",(0,r.kt)("inlineCode",{parentName:"p"},"BooksApiResponse")," to become type ",(0,r.kt)("inlineCode",{parentName:"p"},"[Book]"),"."),(0,r.kt)("p",null,"Finally, since we no longer have any reference to type ",(0,r.kt)("inlineCode",{parentName:"p"},"BooksApiResponse")," this becomes a loose type, and so the transform will purge it from the GraphQL schema."),(0,r.kt)("h2",{id:"transform-scopes"},"Transform scopes"),(0,r.kt)("p",null,"In the paragraph above we've explored how to use the transform to replace field Types.\nThe transform always replaces the type of the source field with the one of the target."),(0,r.kt)("p",null,"However, the transform also allows you to pass a scope property, which values can be ",(0,r.kt)("inlineCode",{parentName:"p"},"config")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"hoistValue"),"."),(0,r.kt)("p",null,"We could say that the scope property could also take a ",(0,r.kt)("inlineCode",{parentName:"p"},"type")," value, but since it's the minimum requirement to replace the Type, this is considered the default scope and so it wouldn't make sense to pass it when you desire just this behaviour."),(0,r.kt)("h3",{id:"scope-config"},"scope: config"),(0,r.kt)("p",null,"When you pass ",(0,r.kt)("inlineCode",{parentName:"p"},"config: scope")," the transform will replace the full field config.\nA field config includes properties of the field such as description, type, args, resolve, subscribe, deprecationReason, extensions, astNode."),(0,r.kt)("p",null,"As you can see this is very comprehensive as it includes things like arguments as well as the resolve and subscribe functions."),(0,r.kt)("p",null,"This can be useful when you have custom resolve functions on your target field and so you are happy to replace the source field entirely.\nHowever, you should be careful in doing this when you fully understand the implications of the behaviour for your replaced field."),(0,r.kt)("h3",{id:"scope-hoistvalue"},"scope: hoistValue"),(0,r.kt)("p",null,"We have seen how ",(0,r.kt)("inlineCode",{parentName:"p"},"hoistValue"),' can be useful in the full example described in the "How to use?" paragraph.'),(0,r.kt)("p",null,"Once again, by default, the transform will replace the Type of the field only.\nWhen passing ",(0,r.kt)("inlineCode",{parentName:"p"},"scope: hoistValue")," in addition to replacing the Type, the transform will wrap the resolver of the original field (source) with a function. This function intercepts the return value of the resolver to ultimately return only the direct child property that has the same name as the target field; hence performing value hoisting."),(0,r.kt)("p",null,"Taking into account the original schema shared above, originally ",(0,r.kt)("inlineCode",{parentName:"p"},"Query.books")," would return a value like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"{\n  books: {\n    books: [{ title: 'abc', author: 'def' }, { title: 'ghi', author: 'lmn' }]\n  }\n}\n")),(0,r.kt)("p",null,"But the wrapping function applied to the original resolver, when passing ",(0,r.kt)("inlineCode",{parentName:"p"},"hoistValue")," scope, will change the value above to this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"{\n  books: [{ title: 'abc', author: 'def' }, { title: 'ghi', author: 'lmn' }]\n}\n")),(0,r.kt)("h2",{id:"additional-type-definitions"},"Additional type definitions"),(0,r.kt)("p",null,"The examples shared so far are simple because we wanted to replace fields with other fields that are available in the original schema."),(0,r.kt)("p",null,"However, sometimes you might want to replace a field Type with something that is not available in the original schema.\nIn this case, the transform allows you to pass additional type definitions that will be injected into your schema so that you can then use them as target field Types."),(0,r.kt)("p",null,"Let's have a look at a Mesh config to be applied to the GraphQL schema shared above:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yml"},"transforms:\n  - replace-field:\n      typeDefs: |\n        type NewAuthor {\n          age: String\n        }\n      # typeDefs: ./customTypeDefs.graphql # for conveniency, you can also pass a .graphql file\n      replacements:\n        - from:\n            type: Author\n            field: age\n          to:\n            type: NewAuthor\n            field: age\n")),(0,r.kt)("p",null,"The config above will change type ",(0,r.kt)("inlineCode",{parentName:"p"},"Author")," from this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-graphql"},"type Author {\n  name: String!\n  age: Int!\n}\n")),(0,r.kt)("p",null,"To this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-graphql"},"type Author {\n  name: String!\n  age: String\n}\n")),(0,r.kt)("h2",{id:"custom-composers"},"Custom composers"),(0,r.kt)("p",null,"Performing value hoisting or replacing the full field config is powerful, but it might not always fully satisfy custom needs.\nFor instance, if you applied transforms to the bare schema (such as field renaming) the built-in value hoisting functionality won't work, because you'd need to hoist the child property provided by the original schema, and not the renamed version."),(0,r.kt)("p",null,"The transform allows you to assign composers to each replace rule, which lets you define your custom logic on top of resolve functions."),(0,r.kt)("p",null,"A composer is a function that wraps the resolve function, giving you access to this before it is executed. You can then intercept its output value so that finally you can also define a custom return value."),(0,r.kt)("p",null,"Let's look at an example.\nCurrently, our ",(0,r.kt)("inlineCode",{parentName:"p"},"Book")," type has a ",(0,r.kt)("inlineCode",{parentName:"p"},"code")," field, we want to replace this field and turn it into a boolean. Our logic assumes that if we have a book code, it means this book is available in our store.\nEventually, we want to completely replace ",(0,r.kt)("inlineCode",{parentName:"p"},"code")," with ",(0,r.kt)("inlineCode",{parentName:"p"},"isAvailable"),"; as you can see this requires implementing custom logic."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yml"},"transforms:\n  - replace-field:\n      typeDefs: |\n        type NewBook {\n          isAvailable: Boolean\n        }\n      replacements:\n        - from:\n            type: Book\n            field: code\n          to:\n            type: NewBook\n            field: isAvailable\n          composer: ./customResolvers.js#isAvailable\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"// customResolvers.js\n\nmodule.exports = {\n  isAvailable: next => async (root, args, context, info) => {\n    // 'next' is the original resolve function\n    const code = await next(root, args, context, info);\n    return Boolean(code);\n  },\n};\n")),(0,r.kt)("p",null,"Now our ",(0,r.kt)("inlineCode",{parentName:"p"},"code")," field will return a Boolean as per custom logic implemented through the javascript function above."),(0,r.kt)("p",null,"We probably want to finish this up with an extra touch to rename the field ",(0,r.kt)("inlineCode",{parentName:"p"},"code")," to ",(0,r.kt)("inlineCode",{parentName:"p"},"isAvailable"),", even though that's a detail beyond the scope of the replace field transform."),(0,r.kt)("p",null,"Let's wrap this up:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yml"},"transforms:\n  - replace-field:\n      typeDefs: |\n        type NewBook {\n          isAvailable: Boolean\n        }\n      replacements:\n        - from:\n            type: Query\n            field: books\n          to:\n            type: BooksApiResponse\n            field: books\n          scope: hoistValue\n        - from:\n            type: Book\n            field: code\n          to:\n            type: NewBook\n            field: isAvailable\n          composer: ./customResolvers.js#isAvailable\n    - rename:\n      mode: bare | wrap\n      renames:\n        - from:\n            type: Book\n            field: code\n          to:\n            type: Book\n            field: isAvailable\n")),(0,r.kt)("p",null,"And now we have the following shiny GraphQL schema:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-graphql"},"type Query {\n  books: [Book]\n}\n\ntype Book {\n  title: String!\n  author: Author!\n  isAvailable: Boolean\n}\n\ntype Author {\n  name: String!\n  age: Int!\n}\n")))}c.isMDXComponent=!0}}]);